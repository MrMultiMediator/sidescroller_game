class Player_template:
    """Template code generation for the Player class of autogenerated games.
    Each function in this template class generates a function for the generated
    class. These functions in this class can have arguments for customization
    of the Player's functionality."""

    def gen_imports_and_action(self):
        self.imports_and_action = f'from pygame.sprite import Sprite\n'
        self.imports_and_action += f'from pygame.transform import flip\n'
        self.imports_and_action += f'from pygame import image, Surface\n'
        self.imports_and_action += f'import pygame\n'
        self.imports_and_action += f'import json\n'
        self.imports_and_action += f'import os\n'
        self.imports_and_action += f'\n'
        self.imports_and_action += f'class Action:\n'
        self.imports_and_action += f'    def __init__(self, name, status="running"):\n'
        self.imports_and_action += f'        self.name = name\n'
        self.imports_and_action += f'        self.status = status\n'
        self.imports_and_action += f'\n'
        self.imports_and_action += f'    def __repr__(self):\n'
        self.imports_and_action += f'        return self.name\n'
        self.imports_and_action += f'\n'
        self.imports_and_action += '\n'

    def gen_healthbar(self):
        self.healthbar = f'class HealthBar:\n'
        self.healthbar += f'    def __init__(self, bg_w, bg_h, max_hp, max_shield):\n'
        self.healthbar += f'        "Make the dimensions and placement of the healthbar proportional to the size of the game background"\n'
        self.healthbar += f'        self.max_hp = max_hp\n'
        self.healthbar += f'        self.max_shield = max_shield\n'
        self.healthbar += f'        self.x = bg_w*0.85\n'
        self.healthbar += f'        self.y = bg_h*0.05\n'
        self.healthbar += f'        self.w = bg_w*0.1\n'
        self.healthbar += f'        self.h = bg_h*0.015\n'
        self.healthbar += f'\n'
        self.healthbar += f'        self.surf = Surface((int(self.w), int(self.h)))\n'
        self.healthbar += f'\n'
        self.healthbar += f'    def draw(self, hp, shield):\n'
        self.healthbar += f'        ratio = hp / self.max_hp\n'
        self.healthbar += f'        ratio_shield = shield / self.max_shield\n'
        self.healthbar += f'\n'
        self.healthbar += f'        pygame.draw.rect(self.surf, "red", (0., 0., self.w, self.h))\n'
        self.healthbar += f'        pygame.draw.rect(self.surf, "green", (0., 0., self.w*ratio, self.h))\n'
        self.healthbar += f'        pygame.draw.rect(self.surf, "blue", (0., 0., self.w*ratio_shield, self.h))\n'
        self.healthbar += f'\n'
        self.healthbar += '\n'

    def gen_init_func(self, topology):
        self.init_func = f'class Player(Sprite):\n'
        self.init_func += f'    def __init__(self, window_width, window_height, bg_info, gravity, xvel=25):\n'
        self.init_func += f'        with open(__file__.replace(os.path.basename(__file__), "")+"/img/topology.json") as f:\n'
        self.init_func += f'            self.topology = json.load(f)\n'
        self.init_func += f'        self.window_width = window_width\n'
        self.init_func += f'        try:\n'
        self.init_func += f"            self.still_coords = {'x':bg_info['sf_x']*800, 'y': bg_info['floor']-self.topology['bottom']['global']}\n"
        self.init_func += f'        except KeyError:\n'
        self.init_func += f"            self.still_coords = {'x':800, 'y':200}\n"
        self.init_func += f"        self.x = self.still_coords['x']\n"
        self.init_func += f"        self.y = self.still_coords['y']\n"
        self.init_func += f'        self.gravity = gravity\n'
        self.init_func += f'        self.jump_strength = 60\n'
        self.init_func += f'        self.max_hp = 1000.\n'
        self.init_func += f'        self.hp = self.max_hp\n'
        self.init_func += f'        self.max_shield = 1000.\n'
        self.init_func += f'        self.shield = self.max_shield\n'
        self.init_func += f'        self.health_bar = HealthBar(window_width, window_height, self.max_hp, self.max_shield)\n'
        self.init_func += f'        self.x_vel = xvel\n'
        self.init_func += f'        self.y_vel = 0.\n'
        self.init_func += f'        self.frame = 1\n'
        self.init_func += f'        self.time = 0\n'
        self.init_func += f"        self.direction = 'right'\n"
        self.init_func += f"        self.status = 'idle'\n"
        self.init_func += f'        self.bg_info = bg_info\n'
        self.init_func += f'        self.bg_edge = True # Specifies whether the character should move or the background should move\n'
        self.init_func += f'        self.imgdir = "img"\n'
        self.init_func += f'        self.imfile = f"{self.imgdir}/{self.status}_{self.frame}.png"\n'
        self.init_func += f'        self.surf = image.load(self.imfile).convert_alpha()\n'
        self.init_func += f'        self.keys_down = []\n'
        self.init_func += f'        self.load_images()\n'
        self.init_func += f'\n'
        self.init_func += '\n'

    def gen_update_func(self):
        self.update_func = f'    def update(self, bg):\n'
        self.update_func += f'        # delta is how much all the objects should shift to keep the frame of\n'
        self.update_func += f'        # reference w/ the player at the center. If delta remains at zero,\n'
        self.update_func += f'        # that means the player has reached the end of the map and must move.\n'
        self.update_func += f'        delta = 0\n'
        self.update_func += f'\n'
        self.update_func += f'        self.time += 1\n'
        self.update_func += f'\n'
        self.update_func += f'        #disp.blit(self.surf, self.surf.get_rect())\n'
        self.update_func += f'        #disp.blit(self.surf, (self.x, self.y))\n'
        self.update_func += f'\n'
        self.update_func += f'        if "right" not in self.keys_down and "left" not in self.keys_down:\n'
        self.update_func += f'            self.x_vel = 0\n'
        self.update_func += f'\n'
        self.update_func += f'        if self.status == "fall1":\n'
        self.update_func += f'            pass\n'
        self.update_func += f'        # Move right\n'
        self.update_func += f'        elif "right" in self.keys_down:\n'
        self.update_func += f'            if "left" not in self.keys_down:\n'
        self.update_func += f'                self.direction = "right"\n'
        self.update_func += f'                self.walk_run_setup()\n'
        self.update_func += f'\n'
        self.update_func += f"                # If we've right scrolled to the end of the background, stop\n"
        self.update_func += f'                # scrolling the background and start moving the player\n'
        self.update_func += f'                if bg.reached_left_end or bg.reached_right_end:\n'
        self.update_func += f"                    if not self._boundary_reached('right'):\n"
        self.update_func += f'                        self.x += self.x_vel\n'
        self.update_func += f'\n'
        self.update_func += f"                    # If we've gotten back to the center, go back to scrolling the background\n"
        self.update_func += f"                    if bg.reached_right_end and self.x >= self.still_coords['x']:\n"
        self.update_func += f"                        diff = self.still_coords['x'] - self.x\n"
        self.update_func += f'                        self.x += diff\n'
        self.update_func += f'                        bg.x += diff\n'
        self.update_func += f'\n'
        self.update_func += f'                        bg.reached_right_end = False\n'
        self.update_func += f'                else:\n'
        self.update_func += f'                    delta = -self.x_vel\n'
        self.update_func += f'            else:\n'
        self.update_func += f'                if str(self.status) != "jump":\n'
        self.update_func += f'                    self.status = "idle"\n'
        self.update_func += f'\n'
        self.update_func += f'        # Move left\n'
        self.update_func += f'        elif "left" in self.keys_down:\n'
        self.update_func += f'            if "right" not in self.keys_down:\n'
        self.update_func += f'                self.direction = "left"\n'
        self.update_func += f'                self.walk_run_setup()\n'
        self.update_func += f'\n'
        self.update_func += f"                # If we've left scrolled to the end of the background, stop\n"
        self.update_func += f'                # scrolling the background and start moving the player\n'
        self.update_func += f'                if bg.reached_left_end or bg.reached_right_end:\n'
        self.update_func += f"                    if not self._boundary_reached('left'):\n"
        self.update_func += f'                        self.x -= self.x_vel\n'
        self.update_func += f'\n'
        self.update_func += f"                    # If we've gotten back to the center, go back to scrolling the background\n"
        self.update_func += f"                    if bg.reached_left_end and self.x <= self.still_coords['x']:\n"
        self.update_func += f"                        diff = self.still_coords['x'] - self.x\n"
        self.update_func += f'                        self.x += diff\n'
        self.update_func += f'                        bg.x += diff\n'
        self.update_func += f'\n'
        self.update_func += f'                        bg.reached_left_end = False\n'
        self.update_func += f'                else:\n'
        self.update_func += f'                    delta = self.x_vel\n'
        self.update_func += f'            else:\n'
        self.update_func += f'                if str(self.status) != "jump":\n'
        self.update_func += f'                    self.status = "idle"\n'
        self.update_func += f'\n'
        self.update_func += f'        elif str(self.status) == "jump":\n'
        self.update_func += f'            self.y -= self.y_vel\n'
        self.update_func += f'            self.y_vel -= self.gravity\n'
        self.update_func += f'\n'
        self.update_func += f'        # Kneel\n'
        self.update_func += f'        elif "ctrl" in self.keys_down and "j" not in self.keys_down and "k" not in self.keys_down:\n'
        self.update_func += f'            self.status = "kneel"\n'
        self.update_func += f'            self.take_damage(0.1*self.max_hp)\n'
        self.update_func += f'\n'
        self.update_func += f'        elif "j" in self.keys_down:\n'
        self.update_func += f'            if "ctrl" not in self.keys_down and "shift" not in self.keys_down and str(self.status) != "jab1":\n'
        self.update_func += f'                self.status = Action("jab1")\n'
        self.update_func += f'\n'
        self.update_func += f'            if "ctrl" not in self.keys_down and "shift" in self.keys_down and str(self.status) != "uppercut1":\n'
        self.update_func += f'                self.status = Action("uppercut1")\n'
        self.update_func += f'\n'
        self.update_func += f'            if "ctrl" in self.keys_down and "shift" not in self.keys_down and str(self.status) != "kneel_punch1":\n'
        self.update_func += f'                self.status = Action("kneel_punch1")\n'
        self.update_func += f'\n'
        self.update_func += f'        elif "k" in self.keys_down:\n'
        self.update_func += f'            if "ctrl" not in self.keys_down and str(self.status) != "kick1":\n'
        self.update_func += f'                self.status = Action("kick1")\n'
        self.update_func += f'\n'
        self.update_func += f'        elif "l" in self.keys_down:\n'
        self.update_func += f'            self.status = "shoot1"\n'
        self.update_func += f'\n'
        self.update_func += f'        elif "shift" in self.keys_down and len(self.keys_down) == 1:\n'
        self.update_func += f'            self.status = "idle"\n'
        self.update_func += f'\n'
        self.update_func += f'        if len(self.keys_down) == 0 and self.status != "jump" and self.status != "fall1":\n'
        self.update_func += f'            self.status = "idle"\n'
        self.update_func += f'\n'
        self.update_func += f'        self.adjust_y_to_bottom()\n'
        self.update_func += f'\n'
        self.update_func += f'        self.bottom_terminate()\n'
        self.update_func += f'\n'
        self.update_func += f'        self.animate()\n'
        self.update_func += f'\n'
        self.update_func += f'        if self.status != "fall1":\n'
        self.update_func += f'            self.update_health()\n'
        self.update_func += f'\n'
        self.update_func += f'        return delta\n'
        self.update_func += f'\n'
        self.update_func += '\n'

    def gen_walk_run_setup(self, run="run", walk="walk"):
        self.walk_run_setup = f'    def walk_run_setup(self):\n'
        self.walk_run_setup += f'        if self.status == "jump":\n'
        self.walk_run_setup += f'            self.y -= self.y_vel\n'
        self.walk_run_setup += f'            self.y_vel -= self.gravity\n'
        self.walk_run_setup += f'\n'
        self.walk_run_setup += f'            if "shift" in self.keys_down:\n'
        self.walk_run_setup += f'                self.x_vel = 40\n'
        self.walk_run_setup += f'            elif "ctrl" in self.keys_down:\n'
        self.walk_run_setup += f'                self.x_vel = 10\n'
        self.walk_run_setup += f'            else:\n'
        self.walk_run_setup += f'                self.x_vel = 25\n'
        self.walk_run_setup += f'        elif "shift" in self.keys_down:\n'
        self.walk_run_setup += f'            self.status = "{run}"\n'
        self.walk_run_setup += f'            self.x_vel = 40\n'
        self.walk_run_setup += f'        elif "ctrl" in self.keys_down:\n'
        self.walk_run_setup += f'            self.status = "kneel_walk"\n'
        self.walk_run_setup += f'            self.x_vel = 10\n'
        self.walk_run_setup += f'        else:\n'
        self.walk_run_setup += f'            self.status = "{walk}"\n'
        self.walk_run_setup += f'            self.x_vel = 25\n'
        self.walk_run_setup += f'\n'
        self.walk_run_setup += '\n'

    def gen__boundary_reached(self):
        self._boundary_reached = f'    def _boundary_reached(self, direction):\n'
        self._boundary_reached += f"        if direction.lower() == 'left':\n"
        self._boundary_reached += f'            if self.x - self.x_vel < 0:\n'
        self._boundary_reached += f'                return True\n'
        self._boundary_reached += f'            else:\n'
        self._boundary_reached += f'                return False\n'
        self._boundary_reached += f'\n'
        self._boundary_reached += f"        elif direction.lower() == 'right':\n"
        self._boundary_reached += f'            if self.x + self.surf.get_width() + self.x_vel > self.window_width:\n'
        self._boundary_reached += f'                return True\n'
        self._boundary_reached += f'            else:\n'
        self._boundary_reached += f'                return False\n'
        self._boundary_reached += f'\n'
        self._boundary_reached += f'        else:\n'
        self._boundary_reached += f'            raise ValueError("direction argument must be left or right")\n'
        self._boundary_reached += f'\n'
        self._boundary_reached += '\n'

    def gen_update_frame(self):
        self.update_frame = f'    def update_frame(self):\n'
        self.update_frame += f'        if str(self.status) not in self.topology["stop"].keys() and str(self.status) != "jump":\n'
        self.update_frame += f'            self.frame += 1\n'
        self.update_frame += f'\n'
        self.update_frame += f'            if self.frame > len(self.surfaces[str(self.status)]):\n'
        self.update_frame += f'                self.frame = 1\n'
        self.update_frame += f'\n'
        self.update_frame += f'        elif str(self.status) == "jump":\n'
        self.update_frame += f'            self.jump_frame_control()\n'
        self.update_frame += f'\n'
        self.update_frame += f'        else:\n'
        self.update_frame += f'            # Special code for animations that specify the animation to stop at the end rather than looping.\n'
        self.update_frame += f'            # Increase frame until we reach the end\n'
        self.update_frame += f'            if self.topology["stop"][str(self.status)] == "end" and self.frame < len(self.surfaces[str(self.status)]):\n'
        self.update_frame += f'                self.frame += 1\n'
        self.update_frame += f'\n'
        self.update_frame += f'            if self.topology["stop"][str(self.status)] == "beginning":\n'
        self.update_frame += f'                if self.frame == len(self.surfaces[str(self.status)]):\n'
        self.update_frame += f'                    self.frame = 1\n'
        self.update_frame += f'                    self.status.status = "done"\n'
        self.update_frame += f'                elif self.status.status == "running":\n'
        self.update_frame += f'                    self.frame += 1\n'
        self.update_frame += f'\n'
        self.update_frame += f'        #print(f"Frame is {self.frame} : {str(self.status)} : {self.keys_down}")\n'
        self.update_frame += f'\n'
        self.update_frame += '\n'

    def gen_animate_and_load_imgs(self):
        self.animate_and_load_imgs = f'    def animate(self):\n'
        self.animate_and_load_imgs += f'        self.update_frame()\n'
        self.animate_and_load_imgs += f'        self.surf = self.surfaces[str(self.status)][self.frame-1]\n'
        self.animate_and_load_imgs += f'        if self.direction == "left":\n'
        self.animate_and_load_imgs += f'            self.surf = flip(self.surf, True, False)\n'
        self.animate_and_load_imgs += f'\n'
        self.animate_and_load_imgs += f'    def load_images(self, img_json="img_js.json", ext="png"):\n'
        self.animate_and_load_imgs += f'        "Loaded once upon __init__"\n'
        self.animate_and_load_imgs += f'        self.surfaces = {}\n'
        self.animate_and_load_imgs += f'        self.status_fname = {} # Dictionary associating statuses with filenames\n'
        self.animate_and_load_imgs += f'\n'
        self.animate_and_load_imgs += f"        with open(img_json, 'r') as f:\n"
        self.animate_and_load_imgs += f'            img_js = json.load(f)\n'
        self.animate_and_load_imgs += f'\n'
        self.animate_and_load_imgs += f'        for animation in img_js.keys():\n'
        self.animate_and_load_imgs += f'            self.surfaces[animation] = []\n'
        self.animate_and_load_imgs += f'\n'
        self.animate_and_load_imgs += f'            self.status_fname[animation] = img_js[animation]["filename"]\n'
        self.animate_and_load_imgs += f'\n'
        self.animate_and_load_imgs += f'            for frame in range(img_js[animation]["frames"][0], img_js[animation]["frames"][1]+1):\n'
        self.animate_and_load_imgs += f'                filename = f"{self.imgdir}/{self.status_fname[animation]}_{frame}.{ext}"\n'
        self.animate_and_load_imgs += f'                self.surfaces[animation].append(image.load(filename).convert_alpha())\n'
        self.animate_and_load_imgs += f'\n'
        self.animate_and_load_imgs += '\n'

    def gen_update_health_and_take_damage(self):
        self.update_health_and_take_damage = f'    def update_health(self):\n'
        self.update_health_and_take_damage += f'        # Every 1/10th of a second, recharge shields by 2%\n'
        self.update_health_and_take_damage += f'        if self.time % 3 == 0:\n'
        self.update_health_and_take_damage += f'            if self.shield < self.max_shield:\n'
        self.update_health_and_take_damage += f'                self.shield += self.max_shield*0.02\n'
        self.update_health_and_take_damage += f'\n'
        self.update_health_and_take_damage += f'            if self.shield > self.max_shield:\n'
        self.update_health_and_take_damage += f'                self.shield = self.max_shield\n'
        self.update_health_and_take_damage += f'\n'
        self.update_health_and_take_damage += f'        self.health_bar.draw(self.hp, self.shield)\n'
        self.update_health_and_take_damage += f'\n'
        self.update_health_and_take_damage += f'    def take_damage(self, amount):\n'
        self.update_health_and_take_damage += f'        if self.shield > 0:\n'
        self.update_health_and_take_damage += f'            if self.shield >= amount:\n'
        self.update_health_and_take_damage += f'                self.shield -= amount\n'
        self.update_health_and_take_damage += f'            else:\n'
        self.update_health_and_take_damage += f'                amount -= self.shield\n'
        self.update_health_and_take_damage += f'                self.shield = 0\n'
        self.update_health_and_take_damage += f'                self.hp -= amount\n'
        self.update_health_and_take_damage += f'        else:\n'
        self.update_health_and_take_damage += f'            self.hp -= amount\n'
        self.update_health_and_take_damage += f'\n'
        self.update_health_and_take_damage += f'        if self.hp <= 0:\n'
        self.update_health_and_take_damage += f'            self.hp = 0\n'
        self.update_health_and_take_damage += f'            self.status = "fall1"\n'
        self.update_health_and_take_damage += f'\n'
        self.update_health_and_take_damage += '\n'

    def gen_bottom_stuff(self):
        self.bottom_stuff = f'    def adjust_y_to_bottom(self):\n'
        self.bottom_stuff += f'        """If the current status specifies that the y-position of the character needs\n'
        self.bottom_stuff += f'        to change due to a changing bottom location then adjust according to the\n'
        self.bottom_stuff += f'        specifications of the character status"""\n'
        self.bottom_stuff += f'        if str(self.status) in self.topology["bottom"].keys():\n'
        self.bottom_stuff += f'            try:\n'
        self.bottom_stuff += f"                self.y = self.bg_info['floor']-self.topology['bottom'][str(self.status)]['values'][self.frame-1]\n"
        self.bottom_stuff += f'            except Exception as e:\n'
        self.bottom_stuff += f'                pass\n'
        self.bottom_stuff += f'        elif str(self.status) != "jump":\n'
        self.bottom_stuff += f"            self.y = self.bg_info['floor']-self.topology['bottom']['global']\n"
        self.bottom_stuff += f'\n'
        self.bottom_stuff += f'    def bottom_terminate(self):\n'
        self.bottom_stuff += f'        """Terminate an animation, like a jump for example, if the bottom of the\n'
        self.bottom_stuff += f"        character reaches the ground at whatever frame they're in."
        self.bottom_stuff += f'"""\n'
        self.bottom_stuff += f'        if str(self.status) in self.topology["bottom_terminate"].keys():\n'
        self.bottom_stuff += f"            if self.y + self.topology['bottom_terminate'][str(self.status)]['values'][self.frame-1] >= self.bg_info['floor']:\n"
        self.bottom_stuff += f'                self.status = "idle"\n'
        self.bottom_stuff += f'                self.frame = 1\n'
        self.bottom_stuff += f"                self.y = self.still_coords['y']\n"
        self.bottom_stuff += f'\n'
        self.bottom_stuff += '\n'

    def gen_jump(self):
        self.jump = f'    def jump_frame_control(self):\n'
        self.jump += f'        """For jump animation, control how the animation is displayed"""\n'
        self.jump += f'        if self.y_vel >= 0:\n'
        self.jump += f'            if self.frame < len(self.surfaces[str(self.status)]):\n'
        self.jump += f'                self.frame += 1\n'
        self.jump += f'        else:\n'
        self.jump += f'            if self.frame > 1:\n'
        self.jump += f'                self.frame -= 1\n'
        self.jump += '\n'

    def write_class_to_file(self, filename="player.py", topology={}):
        self.gen_imports_and_action()
        self.gen_healthbar()
        self.gen_init_func(topology=topology)
        self.gen_update_func()
        self.gen_walk_run_setup()
        self.gen__boundary_reached()
        self.gen_update_frame()
        self.gen_animate_and_load_imgs()
        self.gen_update_health_and_take_damage()
        self.gen_bottom_stuff()
        self.gen_jump()


        with open(filename, "w") as g:
            g.write(self.imports_and_action)
            g.write(self.healthbar)
            g.write(self.init_func)
            g.write(self.update_func)
            g.write(self.walk_run_setup)
            g.write(self._boundary_reached)
            g.write(self.update_frame)
            g.write(self.animate_and_load_imgs)
            g.write(self.update_health_and_take_damage)
            g.write(self.bottom_stuff)
            g.write(self.jump)
