import pprint


class Player_template:
    """Template code generation for the Player class of autogenerated games.
    Each function in this template class generates a function for the generated
    class. These functions in this class can have arguments for customization
    of the Player's functionality."""

    def gen_imports(self):
        self.imports = "from pygame.sprite import Sprite\n"
        self.imports += "from pygame.transform import flip\n"
        self.imports += "from pygame import image\n"
        self.imports += "import json\n"
        self.imports += "import os\n"
        self.imports += "\n"

    def gen_init_func(self, topology):
        self.init_func = f"class Player(Sprite):\n"
        self.init_func += f"    def __init__(self, window_width, bg_info, xvel=25):\n"
        self.init_func += '        with open(__file__.replace(os.path.basename(__file__), "")+"/img/topology.json") as f:\n'
        self.init_func += f"            self.topology = json.load(f)\n"
        self.init_func += f"        self.window_width = window_width\n"
        self.init_func += "        try:\n"
        self.init_func += "            self.still_coords = {'x':bg_info['sf_x']*800, 'y': bg_info['floor']-self.topology['bottom']['global']}\n"
        self.init_func += "        except KeyError:\n"
        self.init_func += "            self.still_coords = {'x':800, 'y':200}\n"
        self.init_func += f"        self.x = self.still_coords['x']\n"
        self.init_func += f"        self.y = self.still_coords['y']\n"
        self.init_func += f"        self.x_vel = xvel\n"
        self.init_func += f"        self.frame = 1\n"
        self.init_func += f"        self.direction = 'right'\n"
        self.init_func += f"        self.status = 'idle'\n"
        self.init_func += f"        self.bg_info = bg_info\n"
        self.init_func += f"        self.bg_edge = True # Specifies whether the character should move or the background should move\n"
        self.init_func += f'        self.imgdir = "img"\n'
        self.init_func += (
            '        self.imfile = f"{self.imgdir}/{self.status}_{self.frame}.png"\n'
        )
        self.init_func += (
            f"        self.surf = image.load(self.imfile).convert_alpha()\n"
        )
        self.init_func += f"        self.keys_down = []\n"
        self.init_func += f"        self.load_images()\n"
        self.init_func += f"        print(self.surfaces)\n"
        self.init_func += f"\n"

    def gen_update_func(self):
        self.update_func = f"    def update(self, disp, bg):\n"
        self.update_func += f"        # delta is how much all the objects should shift to keep the frame of\n"
        self.update_func += f"        # reference w/ the player at the center. If delta remains at zero,\n"
        self.update_func += f"        # that means the player has reached the end of the map and must move.\n"
        self.update_func += f"        delta = 0\n"
        self.update_func += f"\n"
        self.update_func += f"        #disp.blit(self.surf, self.surf.get_rect())\n"
        self.update_func += f"        #disp.blit(self.surf, (self.x, self.y))\n"
        self.update_func += f"\n"
        self.update_func += f"        # Move right\n"
        self.update_func += f'        if "right" in self.keys_down:\n'
        self.update_func += f'            if "left" not in self.keys_down:\n'
        self.update_func += f'                self.direction = "right"\n'
        self.update_func += f"                self.walk_run_setup()\n"
        self.update_func += f"\n"
        self.update_func += f"                # If we've right scrolled to the end of the background, stop\n"
        self.update_func += (
            f"                # scrolling the background and start moving the player\n"
        )
        self.update_func += (
            f"                if bg.reached_left_end or bg.reached_right_end:\n"
        )
        self.update_func += (
            f"                    if not self._boundary_reached('right'):\n"
        )
        self.update_func += f"                        self.x += self.x_vel\n"
        self.update_func += f"\n"
        self.update_func += f"                    # If we've gotten back to the center, go back to scrolling the background\n"
        self.update_func += f"                    if bg.reached_right_end and self.x >= self.still_coords['x']:\n"
        self.update_func += (
            f"                        diff = self.still_coords['x'] - self.x\n"
        )
        self.update_func += f"                        self.x += diff\n"
        self.update_func += f"                        bg.x += diff\n"
        self.update_func += f"\n"
        self.update_func += f"                        bg.reached_right_end = False\n"
        self.update_func += f"                else:\n"
        self.update_func += f"                    delta = -self.x_vel\n"
        self.update_func += f"            else:\n"
        self.update_func += f'                self.status = "idle"\n'
        self.update_func += f"\n"
        self.update_func += f"        # Move left\n"
        self.update_func += f'        elif "left" in self.keys_down:\n'
        self.update_func += f'            if "right" not in self.keys_down:\n'
        self.update_func += f'                self.direction = "left"\n'
        self.update_func += f"                self.walk_run_setup()\n"
        self.update_func += f"\n"
        self.update_func += f"                # If we've left scrolled to the end of the background, stop\n"
        self.update_func += (
            f"                # scrolling the background and start moving the player\n"
        )
        self.update_func += (
            f"                if bg.reached_left_end or bg.reached_right_end:\n"
        )
        self.update_func += (
            f"                    if not self._boundary_reached('left'):\n"
        )
        self.update_func += f"                        self.x -= self.x_vel\n"
        self.update_func += f"\n"
        self.update_func += f"                    # If we've gotten back to the center, go back to scrolling the background\n"
        self.update_func += f"                    if bg.reached_left_end and self.x <= self.still_coords['x']:\n"
        self.update_func += (
            f"                        diff = self.still_coords['x'] - self.x\n"
        )
        self.update_func += f"                        self.x += diff\n"
        self.update_func += f"                        bg.x += diff\n"
        self.update_func += f"\n"
        self.update_func += f"                        bg.reached_left_end = False\n"
        self.update_func += f"                else:\n"
        self.update_func += f"                    delta = self.x_vel\n"
        self.update_func += f"            else:\n"
        self.update_func += f'                self.status = "idle"\n'
        self.update_func += f"\n"
        self.update_func += f"        # Kneel\n"
        self.update_func += f'        elif "ctrl" in self.keys_down:\n'
        self.update_func += f'            self.status = "kneel"\n'
        self.update_func += f"\n"
        self.update_func += f"        if len(self.keys_down) == 0:\n"
        self.update_func += f'            self.status = "idle"\n'
        self.update_func += f"\n"
        self.update_func += f"        self.adjust_y_to_bottom()\n"
        self.update_func += f"\n"
        self.update_func += f"        self.animate()\n"
        self.update_func += f"\n"
        self.update_func += f"        return delta\n"
        self.update_func += f"\n"

    def gen_walk_run_setup_func(self, run="run", walk="walk"):
        """This function allows for custom animation names for run and walk.
        Default is 'run' and 'walk'"""
        self.walk_run_setup_func = f"    def walk_run_setup(self):\n"
        self.walk_run_setup_func += f'        if "shift" in self.keys_down:\n'
        self.walk_run_setup_func += f'            self.status = "{run}"\n'
        self.walk_run_setup_func += f"            self.x_vel = 40\n"
        self.walk_run_setup_func += f"        else:\n"
        self.walk_run_setup_func += f'            self.status = "{walk}"\n'
        self.walk_run_setup_func += f"            self.x_vel = 25\n"
        self.walk_run_setup_func += f"\n"

    def gen_boundary_reached_func(self):
        self._boundary_reached_func = f"    def _boundary_reached(self, direction):\n"
        self._boundary_reached_func += f"        if direction.lower() == 'left':\n"
        self._boundary_reached_func += f"            if self.x - self.x_vel < 0:\n"
        self._boundary_reached_func += f"                return True\n"
        self._boundary_reached_func += f"            else:\n"
        self._boundary_reached_func += f"                return False\n"
        self._boundary_reached_func += f"\n"
        self._boundary_reached_func += f"        elif direction.lower() == 'right':\n"
        self._boundary_reached_func += f"            if self.x + self.surf.get_width() + self.x_vel > self.window_width:\n"
        self._boundary_reached_func += f"                return True\n"
        self._boundary_reached_func += f"            else:\n"
        self._boundary_reached_func += f"                return False\n"
        self._boundary_reached_func += f"\n"
        self._boundary_reached_func += f"        else:\n"
        self._boundary_reached_func += (
            f'            raise ValueError("direction argument must be left or right")'
        )
        self._boundary_reached_func += f"\n"

    def gen_update_frame_func(self):
        self.update_frame_func = f"    def update_frame(self):\n"
        self.update_frame_func += (
            f'        if self.status not in self.topology["stop"].keys():\n'
        )
        self.update_frame_func += f"            self.frame += 1\n"
        self.update_frame_func += f"        else:\n"
        self.update_frame_func += f"            # Special code for animations that specify the animation to stop at the end rather than looping.\n"
        self.update_frame_func += (
            f"            # Increase frame until we reach the end\n"
        )
        self.update_frame_func += f'            if self.topology["stop"][self.status] == "end" and self.frame < len(self.surfaces[self.status]):\n'
        self.update_frame_func += f"                self.frame += 1\n"
        self.update_frame_func += f"\n"
        self.update_frame_func += (
            f"        if self.frame > len(self.surfaces[self.status]):\n"
        )
        self.update_frame_func += f"            self.frame = 1\n"
        self.update_frame_func += f"\n"
        self.update_frame_func += '        #print(f"Frame is {self.frame} : {self.status} : {self.keys_down}")\n'
        self.update_frame_func += f"\n"

    def gen_animate_func(self):
        self.animate_func = f"    def animate(self):\n"
        self.animate_func += f"        self.update_frame()\n"
        self.animate_func += f"\n"
        self.animate_func += (
            f"        self.surf = self.surfaces[self.status][self.frame-1]\n"
        )
        self.animate_func += f'        if self.direction == "left":\n'
        self.animate_func += f"            self.surf = flip(self.surf, True, False)\n"
        self.animate_func += f"\n"

    def gen_load_images_func(self):
        self.load_images_func = (
            f'    def load_images(self, img_json="img_js.json", ext="png"):\n'
        )
        self.load_images_func += f'        "Loaded once upon __init__"\n'
        self.load_images_func += "        self.surfaces = {}\n"
        self.load_images_func += "        self.status_fname = {} # Dictionary associating statuses with filenames\n"
        self.load_images_func += f"\n"
        self.load_images_func += f"        with open(img_json, 'r') as f:\n"
        self.load_images_func += f"            img_js = json.load(f)\n"
        self.load_images_func += f"\n"
        self.load_images_func += f"        for animation in img_js.keys():\n"
        self.load_images_func += f"            self.surfaces[animation] = []\n"
        self.load_images_func += f"\n"
        self.load_images_func += f'            self.status_fname[animation] = img_js[animation]["filename"]\n'
        self.load_images_func += f"\n"
        self.load_images_func += f'            for frame in range(img_js[animation]["frames"][0], img_js[animation]["frames"][1]+1):\n'
        self.load_images_func += '                filename = f"{self.imgdir}/{self.status_fname[animation]}_{frame}.{ext}"\n'
        self.load_images_func += f"                self.surfaces[animation].append(image.load(filename).convert_alpha())\n"
        self.load_images_func += f"\n"

    def get_adjust_y_to_bottom_func(self):
        self.adjust_y_to_bottom_func = f"    def adjust_y_to_bottom(self):\n"
        self.adjust_y_to_bottom_func += f'        """If the current status specifies that the y-position of the character needs \n'
        self.adjust_y_to_bottom_func += f"        to change due to a changing bottom location then adjust according to the \n"
        self.adjust_y_to_bottom_func += (
            f'        specifications of the character status"""\n'
        )
        self.adjust_y_to_bottom_func += (
            f'        if self.status in self.topology["bottom"].keys():\n'
        )
        self.adjust_y_to_bottom_func += f"            try:\n"
        self.adjust_y_to_bottom_func += f"                self.y = self.bg_info['floor']-self.topology['bottom'][self.status]['values'][self.frame-1]\n"
        self.adjust_y_to_bottom_func += f"            except:\n"
        self.adjust_y_to_bottom_func += f"                pass\n"
        self.adjust_y_to_bottom_func += f"        else:\n"
        self.adjust_y_to_bottom_func += f"            self.y = self.bg_info['floor']-self.topology['bottom']['global']\n"

    def write_class_to_file(self, filename="player.py", topology={}):
        self.gen_imports()
        self.gen_init_func(topology=topology)
        self.gen_update_func()
        self.gen_walk_run_setup_func()
        self.gen_boundary_reached_func()
        self.gen_update_frame_func()
        self.gen_animate_func()
        self.gen_load_images_func()
        self.get_adjust_y_to_bottom_func()

        with open(filename, "w") as g:
            g.write(self.imports)
            g.write(self.init_func)
            g.write(self.update_func)
            g.write(self.walk_run_setup_func)
            g.write(self._boundary_reached_func)
            g.write(self.update_frame_func)
            g.write(self.animate_func)
            g.write(self.load_images_func)
            g.write(self.adjust_y_to_bottom_func)
